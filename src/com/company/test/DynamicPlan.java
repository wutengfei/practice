package com.company.test;

import java.util.Scanner;

/**
 * 动态规划的关键点：
 * 1、最优化原理，也就是最有子结构性质。这指的是一个最优化策略具有这样的性质，无论过去状态和决策如何，
 * 对前面的决策所形成的状态而言，余下的决策必须构成最优策略，简单来说就是一个最优化策略的子策略总是最优的，
 * 如果一个问题满足最优化原理，就称其有最优子结构性质。
 * 2、无后效性，指的是某个状态下的决策的收益，只与状态和决策相关，与达到该状态的方式无关。
 * 3、子问题的重叠性，动态规划将原来指数级的暴力搜索算法改进到了具有多项式时间复杂度的算法，
 * 其中的关键在于解决了荣誉，重复计算的问题，这是动态规划算法的根本目的。
 * 4、总体来说，动态规划算法就是一系列以空间换取时间的算法。
 */
public class DynamicPlan {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
       // System.out.println("请输入台阶数");
     //   int n = scanner.nextInt();
    //    System.out.println("共有" + fun(n) + "种走完" + n + "级台阶的方法");

        int[][] a = {
                {1, 3, 5, 9},
                {8, 1, 3, 4},
                {5, 0, 6, 1},
                {8, 8, 4, 0}};
        System.out.println("数组矩阵的最小路径和为"+minPathSum(a));

    }

    /**
     * 案例一：
     * 有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。
     * 分析：动态规划的实现的关键在于能不能准确合理的用动态规划表来抽象出 实际问题。
     * 在这个问题上，我们让f(n)表示走上n级台阶的方法数。
     * 那么当n为1时，f(n) = 1,n为2时，f(n) =2,就是说当台阶只有一级的时候，方法数是一种，
     * 台阶有两级的时候，方法数为2。那么当我们要走上n级台阶，必然是从n-1级台阶迈一步或者是从n-2级台阶迈两步，
     * 所以到达n级台阶的方法数必然是到达n-1级台阶的方法数加上到达n-2级台阶的方法数之和。
     * 即f(n) = f(n-1)+f(n-2)，我们用dp[n]来表示动态规划表，dp[i],i>0,i<=n,表示到达i级台阶的方法数。
     *
     * @param n 多少级台阶
     * @return 多少种走完n级台阶的方法
     */
    private static int fun(int n) {
        if (n == 1 || n == 2)
            return n;
        else
            return fun(n - 1) + fun(n - 2);
    }


    /**
     * 案例2：
     * 给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后达到右下角的位置，路径中所有数字累加起来就是路径和，
     * 返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,0,6,1,0就是最小路径和，返回12.
     * 1 3 5 9
     * 8 1 3 4
     * 5 0 6 1
     * 8 8 4 0
     * 分析：对于这个题目，假设m是m行n列的矩阵，那么我们用dp[m][n]来抽象这个问题，
     * dp[i][j]表示的是从原点到i,j位置的最短路径和。我们首先计算第一行和第一列，直接累加即可，
     * 那么对于其他位置，要么是从它左边的位置达到，要么是从上边的位置达到，我们取左边和上边的较小值，
     * 然后加上当前的路径值，就是达到当前点的最短路径。然后从左到右，从上到下依次计算即可。
     */
    private static int minPathSum(int[][] m) {
        if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
            return 0;
        }
        int rows = m.length;
        int cols = m[0].length;
        int[][] dp = new int[rows][cols];
        dp[0][0] = m[0][0];
        //第一行都是前面的累加
        for (int j = 1; j < cols; j++) {
            dp[0][j] = dp[0][j - 1] + m[0][j];
        }
        //第一列都是上面的累加
        for (int i = 1; i < cols; i++) {
            dp[i][0] = dp[i - 1][0] + m[i][0];
        }
        //构建动态规划表dp
        for (int i = 1; i < cols; i++) {
            for (int j = 1; j < cols; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
            }
        }
        return dp[rows - 1][cols - 1];
    }
}
